---
layout: post
title: "How to Create a Simple Encoder and Decoder with C++ the Right Way"
date: 2025-03-03 16:27:54
image: '/assets/img/cppdaily/encode-decode-cpp.jpg'
description: "ðŸš€ Improving the code shown in the short videos."
tags:
- cpp
- cppdaily
---

![{{ page.title }}]({{ page.image }} '{{ page.description }}')

---

A while ago I posted on [Shorts](https://www.youtube.com/shorts/AIp14SlwrPQ), [Reels](https://www.instagram.com/p/DDvS9cRS8O8/) and [Tik Tok](https://www.tiktok.com/@terminalroot/video/7449902173179088133) a code that created a simple and fast way to encode and decode *strings* that can be used for countless situations where people only expect encoders like: [base64](https://en.wikipedia.org/wiki/Base64), for example.

Therefore, this method makes it a little more difficult to know which algorithm to use to decode. The [C++](https://terminalroot.com/tags#cpp) code was summarized as follows:


<!-- SQUARE - GAMES ROOT -->
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
style="display:inline-block;width:336px;height:280px"
data-ad-client="ca-pub-2838251107855362"
data-ad-slot="5351066970"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

{% highlight cpp %}
#include <iostream>

constexpr auto encode = [](auto S){
    while((*S++)++);
};

constexpr auto decode = [](auto S){
    while(--(*S++));
};

int main(int argc, char **argv){
    std::string str {};
    if(argc > 1){
        str = argv[1];
    }else{ return EXIT_FAILURE;}

    encode(str.data());
    std::cout << "Encode: " << str << '\n';

    decode(str.data());
    std::cout << "Decode: " << str << '\n';

    return EXIT_SUCCESS;
}
{% endhighlight %}

Although it works, **this code has some problems**:
+ The ideal is not to use `constexpr`, we are modifying the [pointer](https://en.wikipedia.org/wiki/Pointer_(computer_programming)) of the *string*, making the function of type `void` is the most logical;
+ The `encode` function does not check for *end of line* and this results in a serious problem that causes memory corruption.

I realized this when I was implementing it in a solution I was creating, where I just copied the code generated by the `encode` function and used it in an application and when I tried to run it, the following error appeared:
{% highlight txt %}
*** stack smashing detected ***: terminated
Aborted (core image saved)
{% endhighlight %}

Therefore, the corrected code looks like this:

{% highlight cpp %}
#include <iostream>

void encode(char * s) {
    while (*s != '\0') { // Check the end of the string
        ++(*s); // Increment the current character
        ++s; // Advance to the next character
    }
}

void decode(char * s) {
    while (*s != '\0') { // Check the end of the string
        --(*s); // Decrement the current character
        ++s; // Advance to the next character
    }
}

int main(int argc, char **argv) {
    if (argc > 1) {
        std::string str = argv[1];

        encode(str.data());
        std::cout << "Encode: " << str << '\n';

        decode(str.data());
        std::cout << "Decode: " << str << '\n';
    }

    return EXIT_SUCCESS;
}
{% endhighlight %}
Now if you copy the encoded result you can use it to decode in another implementation without having a *stack smashing*.

To confirm this, you can use [flags](https://terminalroot.com/10-flags-and-parameters-tips-for-gnu-gcc/) that check if there was a memory violation, for example:
{% highlight bash %}
g++ -g -Wpedantic -Wall -Werror -fsanitize=address encode.cpp
{% endhighlight %}

After running, for example:
{% highlight bash %}
./a.out "Terminal Root"
Encode: Ufsnjobm!Sppu
Decode: Terminal Root
{% endhighlight %}

---

If you want to make it even more difficult, you can use `loops` to run the function as many times as you want and use the same number of times to decode, for example, what I'm talking about without *loops*:

That's it, modifies the string 4 times and we use it 4 times again to return the string original:

{% highlight cpp %}
encode(str.data());
encode(str.data());
encode(str.data());
encode(str.data());
std::cout << "Encode: " << str << '\n';

decode(str.data());
decode(str.data());
decode(str.data());
decode(str.data());
std::cout << "Decode: " << str << '\n';
{% endhighlight %}

Or using a *loop* `for`:
{% highlight cpp %}
for(int i = {}; i < 4; ++i){
    encode(str.data());
}
std::cout << "Encode: " << str << '\n';

for(int i = {}; i < 4; ++i){
    decode(str.data());
}
std::cout << "Decode: " << str << '\n';
{% endhighlight %}

In both cases the output will be the same:
{% highlight bash %}
./a.out "Terminal Root"
Encode: Xivqmrep$Vssx
Decode: Terminal Root
{% endhighlight %}

---

How does it work?
- **Encode**: Each character of the string is incremented by **1**. For example:
- 'T' -> 'U'
- 'e' -> 'f'
- 'r' -> 's'
- etc.
- **Decode**: Each character of the string is decremented by **1**, reversing the `encode` operation. For example:
- 'U' -> 'T'
- 'f' -> 'e'
- 's' -> 'r'
- etc.

---

For more information, I suggest the following links:
+ <https://cplusplus.com/reference/string/string/>
+ <https://learn.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170>
+ <https://github.com/isocpp/CppCoreGuidelines>
